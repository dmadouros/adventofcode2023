/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package starter

import kotlin.math.min
import kotlin.math.pow

class Part1 {
  fun exec() {
    val results = this::class
      .java
      .getResourceAsStream("/input.txt")
      .bufferedReader()
      .readLines()
      .map { card ->
        card.split(":").last()
      }
      .map { card ->
        val (winningNumbers, numbers) = card.split("|")
        val wn = winningNumbers.trim().split("""\s+""".toRegex()).map(String::toInt)
        val n = numbers.trim().split("""\s+""".toRegex()).map(String::toInt)
        wn to n
      }
      .map { (winningNumbers, n) ->
        winningNumbers.toSet().intersect(n.toSet())
      }
      .map { numbers ->
        if (numbers.isNotEmpty()) {
          2.0.pow((numbers.size - 1).toDouble())
        } else {
          0
        }
      }
      .map { it.toInt() }
      .sum()


    println(results)
  }
}

data class Card(val id: Int, val winningNumbers: List<Int>, val numbers: List<Int>) {
  val matchSize: Int
  init {
    matchSize = matches().size
  }

  private fun matches(): Set<Int> = winningNumbers.toSet().intersect(numbers.toSet())
}

class Part2 {
  fun exec() {
    val cards = this::class
      .java
      .getResourceAsStream("/input.txt")
      .bufferedReader()
      .readLines()
      .map { card ->
        val (first, last) = card.split(":")
        val regex = """Card\s+(\d+)""".toRegex()
        val matchResult = regex.find(first)
        val (cardId) = matchResult!!.destructured
        cardId.toInt() to last
      }
      .map { (cardId, card) ->
        val (winningNumbers, numbers) = card.split("|")
        val wn = winningNumbers.trim().split("""\s+""".toRegex()).map(String::toInt)
        val n = numbers.trim().split("""\s+""".toRegex()).map(String::toInt)
        Card(id = cardId, winningNumbers = wn, numbers = n)
      }

    val results = emptyMap<Int, Pair<Int, Int>>().toMutableMap()

    cards.forEach { card ->
      val matchCount = card.matchSize
      if (results.containsKey(card.id)) {
        results[card.id] = matchCount to (results[card.id]!!.second + 1)
      } else {
        results[card.id] = matchCount to 1
      }
      (1..results[card.id]!!.second).forEach {
        cards.subList(card.id, min(card.id + matchCount, cards.size)).forEach { match ->
          if (results.containsKey(match.id)) {
            results[match.id] = match.matchSize to (results[match.id]!!.second + 1)
          } else {
            results[match.id] = match.matchSize to 1
          }
        }
      }
    }

    println(results.values.sumOf { it.second })
  }
}

fun main() {
  Part2().exec()
}
